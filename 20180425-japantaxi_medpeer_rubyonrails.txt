JapanTaxi x MedPeer Ruby/Rails勉強会

1.レガシーシステム(メドピア)：
リライトのリスクは高い
・不確実性が高く規模が見えづらい
・新たなバグがある
etc
しかし、リファクタリングだけでは改善できないなど様々な理由でリライトを決断
リライトの範囲
少しづつリライトすることで、ユーザへ価値を素早く届ける
DBの同期ー＞DB-sync
DB-sync
旧DBから新DBに同期するシステム
旧DB→新DBはあるが、逆は無い
新DBの値はapi経由で取得
既存コード
既存コードはリファレンスとして利用する
                   に縛られた設計にしない


2.rails graphQL(japanTaxi)
GraphQLを採用した理由
クライアントとサーバ両方の課題を解決できる→関連のないuserとrepositoryを両方抽出できる
標準で用意されたAPIドキュメントがある
スキーマの定義から自動生成される
httpのメソッドやステータスをAPI表現に使わない→get postとか無視
フィールドがurlに対応する
フィールドがobject型ならネストできる
どういう場合に採用できるか
・複数のクライアントアプリケーションがある
・API数が多い
・ネストしたリソースを取得したい
・ドキュメント作成のコストを低減できる


3.技術的負債との戦いの歴史(japantaxi)
2016年のシステム
毎朝再起動が必要だった
27万行のコード　
ドキュメント無し
リライト後の負債
・railsっぽく無い
・写経担当しか分からないコード
GitFlow → GitHub Flow
相変わらず負債を抱えていた
ボーイスカウトルール
https://qiita.com/eKushida/items/c3c57dcf50a4c8905d77


4.UnicornでActionCableを使おうとしてハマりかけたこと(メドピア)
コネクションによるプロセスの枯渇が起こるんじゃ無いか？
調査→githubにあるドキュメント
結果、コンストラクタでスレッドを生成していたため、HTTPとは都合が異なる。
↓
思ったよりプロセス枯渇は起きなさそう


5.gem phony_rails(japantaxi)
外国にもSMSが届けたい
そこでphony_railsを発見


6.Enumraize
